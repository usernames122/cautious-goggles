import { decodeType, Decoder, DecoderFunction } from './types';
declare type evalOver<t> = t extends unknown ? decodeType<t> : never;
declare type getSumOfArray<arr> = arr extends (infer elements)[] ? elements : never;
export declare const union: <decoders extends Decoder<unknown>[]>(...decoders: decoders) => (value: unknown) => evalOver<getSumOfArray<decoders>>;
declare type intersectUnion<U> = (U extends unknown ? (_: U) => void : never) extends (_: infer I) => void ? I : never;
declare type asObject<T extends unknown[]> = {
    [K in Exclude<keyof T, keyof []>]: {
        _: decodeType<T[K]>;
    };
};
declare type values<T> = T[keyof T];
declare type fromObject<T> = T extends {
    _: infer V;
} ? V : never;
declare type getProductOfDecoderArray<arr extends Decoder<unknown>[]> = fromObject<intersectUnion<values<asObject<arr>>>> extends infer P ? {
    [K in keyof P]: P[K];
} : never;
export declare const intersection: <decoders extends Decoder<unknown>[]>(...decoders: decoders) => (value: unknown) => getProductOfDecoderArray<decoders>;
export declare const nullable: <T extends Decoder<unknown>>(decoder: T) => DecoderFunction<decodeType<T> | null>;
export declare const optional: <T extends Decoder<unknown>>(decoder: T) => DecoderFunction<decodeType<T> | undefined>;
export declare function array<D extends Decoder<unknown>>(decoder: D): DecoderFunction<decodeType<D>[]>;
export declare const set: <D extends Decoder<unknown>>(decoder: D) => DecoderFunction<Set<decodeType<D>>>;
export declare const map: <K, D extends Decoder<unknown>>(decoder: D, key: (x: decodeType<D>) => K) => DecoderFunction<Map<K, decodeType<D>>>;
export declare function dict<D extends Decoder<unknown>, K extends string = string>(decoder: D, keys?: ReadonlyArray<K>): DecoderFunction<Map<K, decodeType<D>>>;
export {};
