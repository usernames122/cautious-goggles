"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.record = exports.field = exports.fields = exports.fieldDecoder = exports.tuple = exports.literal = void 0;
var pojo_1 = require("./pojo");
var types_1 = require("./types");
var utils_1 = require("./utils");
var literal = function (literal) {
    return function (value) {
        pojo_1.assert_is_pojo(value);
        if (literal !== value) {
            throw "The value `" + JSON.stringify(value) + "` is not the literal `" + JSON.stringify(literal) + "`";
        }
        return literal;
    };
};
exports.literal = literal;
var tuple = function (decoderA, decoderB) {
    return function (value) {
        pojo_1.assert_is_pojo(value);
        if (!Array.isArray(value)) {
            throw "The value `" + JSON.stringify(value) + "` is not a list and can therefore not be parsed as a tuple";
        }
        if (value.length !== 2) {
            throw "The array `" + JSON.stringify(value) + "` is not the proper length for a tuple";
        }
        var a = value[0], b = value[1];
        return [types_1.decode(decoderA)(a), types_1.decode(decoderB)(b)];
    };
};
exports.tuple = tuple;
exports.fieldDecoder = Symbol('field-decoder');
var fields = function (decoder, continuation) {
    var dec = function (value) {
        pojo_1.assert_is_pojo(value);
        var decoded = types_1.decode(decoder)(value);
        return continuation(decoded);
    };
    utils_1.tag(dec, exports.fieldDecoder);
    return dec;
};
exports.fields = fields;
var field = function (key, decoder) {
    var _a;
    return exports.fields((_a = {}, _a[key] = decoder, _a), function (x) { return x[key]; });
};
exports.field = field;
var record = function (s) {
    return function (value) {
        pojo_1.assert_is_pojo(value);
        if (!pojo_1.isPojoObject(value)) {
            throw "Value `" + value + "` is not of type `object` but rather `" + typeof value + "`";
        }
        return Object.entries(s)
            .map(function (_a) {
            var key = _a[0], decoder = _a[1];
            if (decoder[exports.fieldDecoder] === true) {
                return [key, types_1.decode(decoder)(value)];
            }
            try {
                var jsonvalue = value[key];
                return [key, types_1.decode(decoder)(jsonvalue)];
            }
            catch (message) {
                throw (message +
                    ("\nwhen trying to decode the key `" + key + "` in `" + JSON.stringify(value) + "`"));
            }
        })
            .reduce(function (acc, _a) {
            var _b;
            var key = _a[0], value = _a[1];
            return (__assign(__assign({}, acc), (_b = {}, _b[key] = value, _b)));
        }, {});
    };
};
exports.record = record;
