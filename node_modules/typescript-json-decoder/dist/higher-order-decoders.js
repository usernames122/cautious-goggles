"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dict = exports.map = exports.set = exports.array = exports.optional = exports.nullable = exports.intersection = exports.union = void 0;
var primitive_decoders_1 = require("./primitive-decoders");
var pojo_1 = require("./pojo");
var types_1 = require("./types");
var union = function () {
    var decoders = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        decoders[_i] = arguments[_i];
    }
    return function (value) {
        pojo_1.assert_is_pojo(value);
        if (decoders.length === 0) {
            throw "Could not match any of the union cases";
        }
        var decoder = decoders[0], rest = decoders.slice(1);
        try {
            return types_1.decode(decoder)(value);
        }
        catch (messageFromThisDecoder) {
            try {
                return exports.union.apply(void 0, rest)(value);
            }
            catch (message) {
                throw messageFromThisDecoder + "\n" + message;
            }
        }
    };
};
exports.union = union;
var combineObjectProperties = function (a, b) {
    var keys = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], Object.getOwnPropertyNames(a)), Object.getOwnPropertySymbols(a)), Object.getOwnPropertyNames(b)), Object.getOwnPropertySymbols(b));
    return keys.reduce(function (acc, key) {
        var _a;
        var aProp = a[key];
        var bProp = b[key];
        return __assign(__assign({}, acc), (_a = {},
            _a[key] = key in a
                ? key in b
                    ? (function () {
                        try {
                            return combineResults(aProp, bProp);
                        }
                        catch (message) {
                            throw message + "\nWhile trying to combine results for field '" + String(key) + "'";
                        }
                    })()
                    : aProp
                : bProp,
            _a));
    }, {});
};
// Custom classes aren't allowed do to complications when extracting private
// fields and such
var validatePrototype = function (a) {
    var proto = Object.getPrototypeOf(a);
    if (proto !== Object.prototype && proto !== Array.prototype) {
        throw "Only Object, and Array, and the primitive types are allowed in intersections, but got " + proto.constructor.name;
    }
};
// For intersections with primitive types, we compare the results to
// make sure they are equal. With objects, recursively combine any properties
var combineResults = function (a, b) {
    var jsType = typeof a;
    if (jsType !== typeof b) {
        throw "Cannot form intersection of " + typeof a + " and " + typeof b + ", but got " + a + " and " + b;
    }
    else if (jsType === 'function') {
        throw "Combining functions in intersections is not supported";
    }
    else if (jsType === 'object') {
        if ([a, b].some(function (x) { return x === null; })) {
            var nonNull = [a, b].find(function (x) { return x !== null; });
            if (nonNull !== undefined) {
                throw "Cannot intersect null with non-null value " + nonNull;
            }
            else {
                return null;
            }
        }
        validatePrototype(a);
        validatePrototype(b);
        var result = combineObjectProperties(a, b);
        var base = Array.isArray(a) || Array.isArray(b) ? [] : {};
        return Object.assign(base, result);
    }
    else {
        if (a !== b) {
            throw "Intersections must produce matching values in all branches, but got " + a + " and " + b;
        }
        return a;
    }
};
// NB: if multiple cases create properties with identical keys, only the last one is kept
var intersection = function () {
    var decoders = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        decoders[_i] = arguments[_i];
    }
    return function (value) {
        pojo_1.assert_is_pojo(value);
        var errors = [];
        var results = [];
        for (var _i = 0, decoders_1 = decoders; _i < decoders_1.length; _i++) {
            var decoder = decoders_1[_i];
            try {
                results.push(types_1.decode(decoder)(value));
            }
            catch (message) {
                errors.push(message);
            }
        }
        if (errors.length === 0) {
            return results.length === 0
                ? {}
                : results.reduce(function (acc, result) { return combineResults(acc, result); });
        }
        else {
            errors.push("Could not match all of the intersection cases");
            throw errors.join('\n');
        }
    };
};
exports.intersection = intersection;
var nullable = function (decoder) {
    return exports.union(primitive_decoders_1.nil, decoder);
};
exports.nullable = nullable;
var optional = function (decoder) { return exports.union(primitive_decoders_1.undef, decoder); };
exports.optional = optional;
function array(decoder) {
    return function (xs) {
        pojo_1.assert_is_pojo(xs);
        var arrayToString = function (arr) { return "" + JSON.stringify(arr); };
        if (!Array.isArray(xs)) {
            throw "The value `" + arrayToString(xs) + "` is not of type `array`, but is of type `" + typeof xs + "`";
        }
        var index = 0;
        try {
            return xs.map(function (x, i) {
                index = i;
                return types_1.decode(decoder)(x);
            });
        }
        catch (message) {
            throw (message +
                ("\nwhen trying to decode the array (at index " + index + ") `" + arrayToString(xs) + "`"));
        }
    };
}
exports.array = array;
var set = function (decoder) {
    return function (list) {
        pojo_1.assert_is_pojo(list);
        try {
            return new Set(types_1.decode(array(decoder))(list));
        }
        catch (message) {
            throw message + "\nand can therefore not be parsed as a set";
        }
    };
};
exports.set = set;
var map = function (decoder, key) {
    return function (listOfObjects) {
        pojo_1.assert_is_pojo(listOfObjects);
        try {
            var parsedObjects = types_1.decode(array(decoder))(listOfObjects);
            var map_1 = new Map(parsedObjects.map(function (value) { return [key(value), value]; }));
            if (parsedObjects.length !== map_1.size) {
                console.warn("Probable duplicate key in map: List `" + parsedObjects + "` isn't the same size as the parsed `" + map_1 + "`");
            }
            return map_1;
        }
        catch (message) {
            throw message + "\nand can therefore not be parsed as a map";
        }
    };
};
exports.map = map;
function dict(decoder, keys) {
    return function (map) {
        pojo_1.assert_is_pojo(map);
        if (!pojo_1.isPojoObject(map)) {
            throw "Value `" + map + "` is not an object and can therefore not be parsed as a map";
        }
        var decodedPairs = Object.entries(map).map(function (_a) {
            var key = _a[0], value = _a[1];
            try {
                if (keys && !types_1.isKey(key, keys)) {
                    throw "Key `" + key + "` is not in given keys";
                }
                return [key, types_1.decode(decoder)(value)];
            }
            catch (message) {
                throw message + ("\nwhen decoding the key `" + key + "` in map `" + map + "`");
            }
        });
        return new Map(decodedPairs);
    };
}
exports.dict = dict;
